package gameObjects;

import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.geom.AffineTransform;
import java.awt.geom.Area;
import java.awt.geom.GeneralPath;
import java.util.ArrayList;
import java.util.Random;

import main.Window;

public class GameObjectHandler {
	private ArrayList<GameObject> objectList;
	private boolean running;
	private HUD hud;
	private Random rand;
	private int powerTick;
	private boolean powerOut, spawnPowerUp;

	public GameObjectHandler(HUD hud) {
		powerOut = false;
		spawnPowerUp = true;
		objectList = new ArrayList<GameObject>();
		running = true;
		rand = new Random();
		powerTick = Window.secToTicks(30.0);
		this.hud = hud;
	}
	
	public void update() {
		if (running) {
			for (int i = 0; i < objectList.size(); i++) {
				GameObject tempObject = objectList.get(i);
				if (tempObject.getId() != "Wall" ){
					checkCollision(tempObject);
				}
				tempObject.update();
				if (powerOut){
					if (tempObject.getId().charAt(0) == 'p'){
						tempObject.setX(2500);
						tempObject.setY(2500);
					}
				}
				if (spawnPowerUp){
					if (tempObject.getId().charAt(0) == 'p'){
						respawnObject(tempObject);
					}
				}
				if (!tempObject.isAlive()) {
					removeObject(tempObject);
				}
			}
			powerTick++;
			if (powerTick == Window.secToTicks(10.0)){
				powerOut = true;
			}
			spawnPowerUp = false;
			if (powerTick >= Window.secToTicks(30.0)){
				powerTick = 0;
				spawnPowerUp = true;
				powerOut = false;
			}
		}
	}

	
	public void checkCollision(GameObject object) {
		AffineTransform at = AffineTransform.getTranslateInstance(object.getX(), object.getY());
		at.rotate(Math.toRadians(object.getAngle() * 22.5), object.image.getWidth() / 2, object.image.getHeight() / 2);
		GeneralPath path = new GeneralPath();
		path.append(object.getBounds().getPathIterator(at), true);
		Area a1 = new Area(path);
		// fill detection bounds
		//g.fill(path);
        //g.setColor(Color.BLUE);
        //g.draw(path.getBounds());
        
		for (int i = 0; i < objectList.size(); i++) {
			GameObject tempObject = objectList.get(i);
			if (object != tempObject) {
				if (checkCollisionOne(a1,tempObject)){
					// bullet collision
					if (object.getId() == "Bullet" && object.getOwner() != tempObject.getId()) {
						// bullet to bullet
						if (tempObject.getId() == "Bullet"){
							object.setAlive(false);
							tempObject.setAlive(false);
						}
						//bullet to powerUp
						if (tempObject.getId().charAt(0) == 'p'){
							object.setAlive(false);
							tempObject.setX(2500);
							tempObject.setY(2500);
						}
						// bullet to tank
						if (tempObject.getId() == "Player1" || tempObject.getId() == "Player2"){
							if (tempObject.hasShield()){
								tempObject.setShield(false);
								object.setAlive(false);
							}else if (!tempObject.hasShield()){
								if (tempObject.getId() == "Player1"){
									hud.add2();
								}else{
									hud.add1();
								}
								object.setAlive(false);
								respawnObject(tempObject);
							}
						}
						if (tempObject.getId() == "Wall"){
							int xBounds[], yBounds[];
							xBounds[0] = object.getX()
							for (int j = i; j < objectList.size(); j++) {
								GameObject tempObject1 = objectList.get(i);
								
								if(checkCollisionOne(a1,tempObject1) && tempObject1.getId() == "Wall"){
									
								}
							}
						}
					}
					// tank collision;
					if ((object.getId() == "Player1") ||(object.getId() == "Player2")){
						// tank to tank
						if ((tempObject.getId() == "Player2") || (tempObject.getId() == "Player1")){
							respawnObject(tempObject);
							respawnObject(object);
						}
						// tank to power up
						if (tempObject.getId().charAt(0) == 'p'){
							object.powered(tempObject.getId());
							tempObject.setX(2500);
							tempObject.setY(2500);
						}
						// tank to wall collisions
						if (tempObject.getId() == "Wall"){
							object.setPrevPov();
						}
					}
				}
			}
		}
	}
	
	
	public Rectangle checkXY(Area a1, GameObject tempObject){
		AffineTransform at = new AffineTransform();
		at = AffineTransform.getTranslateInstance(tempObject.getX(), tempObject.getY());
		at.rotate(Math.toRadians(tempObject.getAngle() * 22.5), tempObject.image.getWidth() / 2, tempObject.image.getHeight() / 2);
		GeneralPath path = new GeneralPath();
		path.append(tempObject.getBounds().getPathIterator(at), true);
		Area a2 = new Area(path);
		a2.intersect(a1);
		return a2.getBounds();
	}
	
	
	
	// respawn object that will not overlap
	public void respawnObject(GameObject object){
		if (object.getId() == "Player1") {
			object.setX(2000);
			object.setY(2000);
		} else if(object.getId() == "Player2"){
			object.setX(3000);
			object.setY(3000);
		} else if(object.getId().charAt(0) == 'p') {
			object.setX(2500);
			object.setY(2500);
		}
		int nextX, nextY, nextAngle;	
		
		nextX = rand.nextInt(Window.WIDTH - 45);
		nextY = rand.nextInt(Window.HEIGHT - 45);
		nextAngle = rand.nextInt(15);
		while (checkSpawn(nextX,nextY,nextAngle,object)){
			nextX = rand.nextInt(Window.WIDTH - 45);
			nextY = rand.nextInt(Window.HEIGHT - 45);
			nextAngle = rand.nextInt(15);
		}
		object.respawn(nextX, nextY, nextAngle);
		
	}

	// check if new object will overlap with current objects;
	public boolean checkSpawn(int nextX, int nextY, int nextAngle, GameObject object){
		AffineTransform at = AffineTransform.getTranslateInstance(nextX, nextY);
		at.rotate(Math.toRadians(nextAngle * 22.5), object.image.getWidth() / 2, object.image.getHeight() / 2);
		GeneralPath path = new GeneralPath();
		path.append(object.getBounds().getPathIterator(at), true);
		Area a1 = new Area(path);
		for (int i = 0; i < objectList.size(); i++) {
			GameObject tempObject = objectList.get(i);
			if (checkCollisionOne(a1,tempObject)){
					return true;
			}else{
					return false;
			}
		}
		return false;
	}
	
	// check collision with object to another object;
	public boolean checkCollisionOne(Area a1, GameObject tempObject){
		AffineTransform at = new AffineTransform();
		at = AffineTransform.getTranslateInstance(tempObject.getX(), tempObject.getY());
		at.rotate(Math.toRadians(tempObject.getAngle() * 22.5), tempObject.image.getWidth() / 2, tempObject.image.getHeight() / 2);
		GeneralPath path = new GeneralPath();
		path.append(tempObject.getBounds().getPathIterator(at), true);
		Area a2 = new Area(path);
		a2.intersect(a1);
		if (!a2.isEmpty()) {
			return true;
		}else{
			return false;
		}
	}

	public void draw(Graphics2D g) {
		
		// running/not paused
		for (int i = objectList.size() - 1; i >= 0 ; i--){
			GameObject tempObject = objectList.get(i);
			tempObject.draw(g);
		}
		
		// hud
		hud.draw(g);
		
		// paused/not running
		if (!running) {
			g.setColor(Color.WHITE);
			g.setFont(new Font(Window.FONTSTYLE, Font.BOLD, 64));
			g.drawString("Paused", Window.WIDTH / 2 - 105, Window.HEIGHT / 2 - 10);
			g.setFont(new Font(Window.FONTSTYLE, Font.BOLD, 32));
			g.drawString("Space to return to menu.", Window.WIDTH / 2 - 180, Window.HEIGHT / 2 + 60);
		}
		
	}

	public void pause() {
		running = !running;
	}

	public boolean isRunning() {
		return running;
	}

	public boolean isPaused() {
		return !running;
	}

	public void addObject(GameObject object) {
		if (running) {
			this.objectList.add(object);
		}
	}

	public void removeObject(GameObject object) {
		if (running) {
			this.objectList.remove(object);
		}
	}

}
