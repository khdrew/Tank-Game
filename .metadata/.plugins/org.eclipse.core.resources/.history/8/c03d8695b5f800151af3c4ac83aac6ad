package gameObjects;

import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.geom.AffineTransform;
import java.awt.geom.Area;
import java.awt.geom.GeneralPath;
import java.util.ArrayList;

import main.Window;

public class GameObjectHandler {
	private ArrayList<GameObject> objectList;
	private boolean running;

	public GameObjectHandler() {
		objectList = new ArrayList<GameObject>();
		running = true;
	}

	public void update() {
		if (running) {
			for (int i = 0; i < objectList.size(); i++) {
				GameObject tempObject = objectList.get(i);
				tempObject.update();
				if (!tempObject.isAlive()) {
					removeObject(tempObject);
				}

			}
		}
	}

	public void checkCollision(GameObject object, Graphics2D g) {

		AffineTransform at = new AffineTransform();

		int x = center + (center - object.image.getWidth()) / 2;
		int y = (height - object.image.getHeight()) / 2;
		at.translate(x, y);
		at.rotate(Math.toRadians(object.getAngle() * 22.5), object.image.getWidth() / 2, object.image.getHeight() / 2);
		GeneralPath path1 = new GeneralPath();
		path1.append(object.getBounds().getPathIterator(at), true);
		
		g.fill(path1);

        g.setColor(Color.BLUE);
        g.draw(path1.getBounds());
		
		
		for (int i = 0; i < objectList.size(); i++) {
			GameObject tempObject = objectList.get(i);
			if (object != tempObject) {
				at = new AffineTransform();
				x = (tempObject.image.getWidth()) / 2;
				y = (tempObject.image.getHeight()) / 2;
				at.translate(x, y);
				at.rotate(Math.toRadians(object.getAngle() * 22.5), object.image.getWidth() / 2, object.image.getHeight() / 2);
				GeneralPath path2 = new GeneralPath();
				path2.append(tempObject.getBounds().getPathIterator(at), true);
				g.fill(path2);

		        g.setColor(Color.BLUE);
		        g.draw(path1.getBounds());
				
				Area a1 = new Area(path1);
				Area a2 = new Area(path2);
				a2.intersect(a1);
				if (!a2.isEmpty()) {
					System.out.println(tempObject.getId());
					System.out.println(object.getId());
					tempObject.setAlive(false);
					object.setAlive(false);
				}
			}
			/*
			 * Rectangle temp1 = object.getBounds();
			 * 
			 * 
			 * GeneralPath path1 = new GeneralPath();
			 * path1.append(temp.getPathIterator(at1), true); for (int i = 0; i
			 * < objectList.size(); i++) { GameObject tempObject =
			 * objectList.get(i); if (object != tempObject) { temp =
			 * tempObject.getBounds(); AffineTransform at2 =
			 * AffineTransform.getTranslateInstance(tempObject.getX()+temp.
			 * getWidth()/2, tempObject.getY() + temp.getHeight()/2);
			 * at2.rotate(Math.toRadians(object.getAngle() * 22.5),
			 * temp.getWidth()/2, temp.getHeight()/2); GeneralPath path2 = new
			 * GeneralPath(); path2.append(temp.getPathIterator(at2), true);
			 * Area a1 = new Area(path1); Area a2 = new Area(path2);
			 * a2.intersect(a1); if (!a2.isEmpty()) { if (tempObject.getId() ==
			 * "Bullet") { tempObject.setAlive(false); object.setAlive(false); }
			 * } } }
			 */
		}
	}

	public void draw(Graphics2D g) {
		for (int i = objectList.size() - 1; i >= 0; i--) {
			GameObject tempObject = objectList.get(i);
			tempObject.draw(g);
			checkCollision(tempObject,g);
		}
		
		if (!running) {
			g.setColor(Color.WHITE);
			g.setFont(new Font(Window.FONTSTYLE, Font.BOLD, 64));
			g.drawString("Paused", Window.WIDTH / 2 - 105, Window.HEIGHT / 2 - 10);
		}

	}

	public void pause() {
		running = !running;
	}

	public boolean isRunning() {
		return running;
	}

	public boolean isPaused() {
		return !running;
	}

	public void addObject(GameObject object) {
		if (running) {
			this.objectList.add(object);
		}
	}

	public void removeObject(GameObject object) {
		if (running) {
			this.objectList.remove(object);
		}
	}

}
